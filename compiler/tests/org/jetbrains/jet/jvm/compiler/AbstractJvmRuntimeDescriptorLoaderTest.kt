/*
 * Copyright 2010-2014 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.jet.jvm.compiler

import org.jetbrains.jet.codegen.GenerationUtils
import org.jetbrains.jet.JetTestUtils
import com.intellij.openapi.util.io.FileUtil
import java.io.File
import org.jetbrains.jet.ConfigurationKind
import org.jetbrains.jet.codegen.GeneratedClassLoader
import org.jetbrains.jet.codegen.forTestCompile.ForTestCompileRuntime
import org.jetbrains.jet.test.util.RecursiveDescriptorComparator
import org.jetbrains.jet.test.TestCaseWithTmpdir
import org.jetbrains.jet.cli.common.output.outputUtils.writeAllTo
import org.jetbrains.kotlin.util.sure
import org.jetbrains.jet.lang.descriptors.*
import org.jetbrains.jet.lang.resolve.scopes.JetScope
import org.jetbrains.jet.lang.types.TypeSubstitutor
import org.jetbrains.jet.lang.resolve.java.JvmAbi
import org.jetbrains.jet.lang.resolve.kotlin.reflect.ReflectKotlinClass
import org.jetbrains.jet.lang.resolve.kotlin.header.KotlinClassHeader
import org.jetbrains.jet.lang.resolve.scopes.WritableScopeImpl
import org.jetbrains.jet.lang.resolve.scopes.RedeclarationHandler
import org.jetbrains.jet.lang.resolve.scopes.WritableScope.LockLevel
import org.jetbrains.jet.renderer.DescriptorRendererBuilder
import org.jetbrains.jet.lang.resolve.name.FqName
import org.jetbrains.jet.renderer.DescriptorRenderer
import org.jetbrains.jet.lang.resolve.kotlin.DeserializedResolverUtils
import org.jetbrains.jet.lang.resolve.name.FqNameUnsafe
import org.jetbrains.jet.lang.resolve.resolveTopLevelClass
import org.jetbrains.jet.lang.resolve.name.SpecialNames
import org.jetbrains.jet.lang.resolve.kotlin.reflect.createModule

public abstract class AbstractJvmRuntimeDescriptorLoaderTest : TestCaseWithTmpdir() {
    class object {
        private val renderer = DescriptorRendererBuilder()
                .setWithDefinedIn(false)
                .setExcludedAnnotationClasses(listOf(
                        ExpectedLoadErrorsUtil.ANNOTATION_CLASS_NAME,
                        "kotlin.deprecated",
                        "kotlin.data",
                        "org.jetbrains.annotations.NotNull",
                        "org.jetbrains.annotations.Nullable",
                        "org.jetbrains.annotations.Mutable",
                        "org.jetbrains.annotations.ReadOnly"
                ).map { FqName(it) })
                .setOverrideRenderingPolicy(DescriptorRenderer.OverrideRenderingPolicy.RENDER_OPEN_OVERRIDE)
                .setIncludeSynthesizedParameterNames(false)
                .setIncludePropertyConstant(false)
                .setVerbose(true)
                .build()
    }

    protected fun doTest(ktFileName: String) {
        val ktFile = File(ktFileName)

        val environment = JetTestUtils.createEnvironmentWithMockJdkAndIdeaAnnotations(myTestRootDisposable, ConfigurationKind.ALL)
        val jetFile = JetTestUtils.createFile(ktFileName, FileUtil.loadFile(ktFile, true), environment.getProject())
        val classFileFactory = GenerationUtils.compileFileGetClassFileFactoryForTest(jetFile)
        val classLoader = GeneratedClassLoader(classFileFactory, null, ForTestCompileRuntime.runtimeJarForTests().toURI().toURL())

        classFileFactory.writeAllTo(tmpdir)

        val module = createModule(classLoader)

        // Since runtime package view descriptor doesn't support getAllDescriptors(), we construct a synthetic package view here.
        // It has in its scope descriptors for all the classes and top level members generated by the compiler
        val actual = object : PackageViewDescriptor {
            val scope = WritableScopeImpl(JetScope.Empty, this, RedeclarationHandler.THROW_EXCEPTION, "runtime descriptor loader test")

            override fun getFqName() = LoadDescriptorUtil.TEST_PACKAGE_FQNAME
            override fun getMemberScope() = scope
            override fun getModule() = module
            override fun <R, D> accept(visitor: DeclarationDescriptorVisitor<R, D>, data: D): R =
                    visitor.visitPackageViewDescriptor(this, data)

            override fun getContainingDeclaration() = throw UnsupportedOperationException()
            override fun getOriginal() = throw UnsupportedOperationException()
            override fun substitute(substitutor: TypeSubstitutor) = throw UnsupportedOperationException()
            override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?) = throw UnsupportedOperationException()
            override fun getAnnotations() = throw UnsupportedOperationException()
            override fun getName() = throw UnsupportedOperationException()
        }

        val scope = actual.getMemberScope()
        scope.changeLockLevel(LockLevel.BOTH)

        for (outputFile in classLoader.getAllGeneratedFiles()) {
            val className = outputFile.relativePath.substringBeforeLast(".class").replace('/', '.').replace('\\', '.')
            if (className.endsWith(JvmAbi.CLASS_OBJECT_SUFFIX)) continue

            val klass = classLoader.loadClass(className).sure("Couldn't load class $className")

            when (ReflectKotlinClass(klass).getClassHeader().kind) {
                KotlinClassHeader.Kind.PACKAGE_FACADE -> {
                    val packageView = module.getPackage(actual.getFqName()) ?: error("Couldn't resolve package ${actual.getFqName()}")
                    for (descriptor in packageView.getMemberScope().getAllDescriptors()) {
                        when (descriptor) {
                            is FunctionDescriptor -> scope.addFunctionDescriptor(descriptor)
                            is PropertyDescriptor -> scope.addPropertyDescriptor(descriptor)
                        }
                    }
                }
                KotlinClassHeader.Kind.CLASS -> {
                    val kotlinFqName = DeserializedResolverUtils.javaFqNameToKotlinFqName(FqName(className))
                    val classDescriptor = resolveClassByFqNameInModule(module, kotlinFqName).sure("Couldn't resolve class $className")
                    if (classDescriptor.getContainingDeclaration() is PackageFragmentDescriptor) {
                        scope.addClassifierDescriptor(classDescriptor)
                    }
                }
            }
        }

        val expected = LoadDescriptorUtil.loadTestPackageAndBindingContextFromJavaRoot(tmpdir, getTestRootDisposable(),
                                                                                       ConfigurationKind.ALL)
        val configuration = RecursiveDescriptorComparator.DONT_INCLUDE_METHODS_OF_OBJECT
                .checkPrimaryConstructors(true)
                .checkPropertyAccessors(true)
                .withRenderer(renderer)
        RecursiveDescriptorComparator.validateAndCompareDescriptors(expected.first, actual, configuration, null)
    }

    private fun resolveClassByFqNameInModule(module: ModuleDescriptor, fqName: FqNameUnsafe): ClassDescriptor? {
        if (fqName.isRoot()) return null

        if (fqName.isSafe()) {
            val topLevel = module.resolveTopLevelClass(fqName.toSafe())
            if (topLevel != null) return topLevel
        }

        val parent = resolveClassByFqNameInModule(module, fqName.parent()) ?: return null
        val shortName = fqName.shortName()
        if (SpecialNames.isClassObjectName(shortName)) {
            return parent.getClassObjectDescriptor()
        }
        return parent.getUnsubstitutedInnerClassesScope().getClassifier(shortName) as? ClassDescriptor
    }
}
